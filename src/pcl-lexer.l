/* PCL - Predicate Constraint Language
 * Copyright (C) 2006 The Boeing Company
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

%{
#include "pcl.h"
#include "pcl-node.h"
#include "pcl-parser.h" /* generated by Bison */
#include "glib-ext.h"   /* only until GLib 2.10 */

#ifdef HAVE_LIBREADLINE

#include <readline/readline.h>
#include <readline/history.h>

#include <setjmp.h>
#include <signal.h>

/* see comments in lexer_input() */
static jmp_buf env;

static void
lexer_signal_handler (gint sig)
{
        longjmp (env, 1);
}

#endif /* HAVE_LIBREADLINE */

#define E_DEDENT        "unindent does not match any outer indentation level"
#define E_EOLS          "EOL while scanning single-quoted string"
#define E_TOKEN         "invalid token"
#define E_TOODEEP       "too many levels of indentation"

#define MAXINDENT       100     /* max indentation level */
#define TABSIZE         8       /* # spaces per tab char */

/* borrowed from the parser */
#define NEW_TREE_NODE(type, loc) \
        g_node_new (pcl_node_new ( \
        (type), (loc).first_line, (loc).first_column))

#define YY_INPUT(buffer, result, max_size) \
        result = lexer_input ((buffer), (max_size))

/* YY_USER_ACTION is always executed prior to the matched rule's action.
 * If there are pending DEDENT tokens to be issued, put the matched text
 * back in the input stream to be rescanned on the next pass.  Otherwise
 * update the parser location variable `yylloc'. */
#define YY_USER_ACTION  \
        if (pending_dedents > 0) \
        { \
                yyless (0); \
                pending_dedents--; \
                return DEDENT; \
        } \
        lexer_update_yylloc ();

/* Global Variables */
static const gchar *input_name = NULL;
static const gchar *cur_prompt = NULL;
static const gchar *alt_prompt = NULL;
static GString *string_buffer = NULL;
static gint eof_token = YY_NULL;
static gint error_code = 0;
static gint in_enclosure = 0;
static gint indent_level = 0;
static gint pending_dedents = 0;
static gint indent_stack[MAXINDENT] = { 0 };
static gboolean is_interactive = FALSE;

/* Parser Declarations */
extern gint yychar;
extern YYLTYPE yylloc;
extern gint yyparse (void);

/* Forward Declarations */
static gint lexer_start (gint token);
static gint lexer_input (gchar *buffer, gsize max_size);
static gint lexer_flush (void);
static gint lexer_indent (const gchar *text);
static gint lexer_process_float (gchar *text, gint length);
static gint lexer_process_integer (gchar *text, gint length);
static gint lexer_process_string (gchar *text);
static gint lexer_process_name (gchar *text);
static void lexer_update_yylloc (void);
static void lexer_quoted_begin (const gchar *text);
static void lexer_quoted_concat (const gchar *text);
static void lexer_quoted_append_chr (gchar c);
static void lexer_quoted_append_hex (const gchar *hex);
static void lexer_quoted_append_oct (const gchar *oct);
static void lexer_quoted_append_str (const gchar *str);
static void lexer_quoted_push_state (const gchar *text);
static gint lexer_quoted_end (void);
gint yyerror (const gchar *message);
%}

D                               [0-9]
O                               [0-7]
L                               [a-zA-Z_]
H                               [a-fA-F0-9]
E                               [Ee][+-]?{D}+
WS                              [ \f\t]
Q                               [rR]?('|\"|'''|\"\"\")

%pointer
%option stack
%x EIN FIN SIN FLUSH BOL
%x DQ SQ TDQ TSQ RDQ RSQ RTDQ RTSQ

%%

<EIN>{WS}*("#"[^\n]*)?\n        /* whitespace - do nothing */
<FIN>{WS}*("#"[^\n]*)?\n        /* whitespace - do nothing */
<SIN>{WS}*("#"[^\n]*)?\n        /* whitespace - do nothing */
<EIN>.                          return lexer_start (EVAL_INPUT);
<FIN>.                          return lexer_start (FILE_INPUT);
<SIN>.                          return lexer_start (SINGLE_INPUT);

<FLUSH>D                        return DEDENT;

"and"                           return KW_AND;
"as"                            return KW_AS;
"assert"                        return KW_ASSERT;
"break"                         return KW_BREAK;
"class"                         return KW_CLASS;
"continue"                      return KW_CONTINUE;
"cut"                           return KW_CUT;
"def"                           return KW_DEF;
"del"                           return KW_DEL;
"elif"                          return KW_ELIF;
"else"                          return KW_ELSE;
"except"                        return KW_EXCEPT;
"exec"                          return KW_EXEC;
"finally"                       return KW_FINALLY;
"for"                           return KW_FOR;
"from"                          return KW_FROM;
"global"                        return KW_GLOBAL;
"if"                            return KW_IF;
"import"                        return KW_IMPORT;
"in"                            return KW_IN;
"is"                            return KW_IS;
"is"{WS}+"not"                  return KW_IS_NOT;
"not"                           return KW_NOT;
"not"{WS}+"in"                  return KW_NOT_IN;
"or"                            return KW_OR;
"pass"                          return KW_PASS;
"predicate"                     return KW_PREDICATE;
"print"                         return KW_PRINT;
"raise"                         return KW_RAISE;
"return"                        return KW_RETURN;
"static"                        return KW_STATIC;
"try"                           return KW_TRY;
"while"                         return KW_WHILE;
"yield"                         return KW_YIELD;

"+="                            return OP_INPLACE_ADD;
"-="                            return OP_INPLACE_SUB;
"*="                            return OP_INPLACE_MUL;
"/="                            return OP_INPLACE_DIV;
"%="                            return OP_INPLACE_MOD;
"**="                           return OP_INPLACE_POW;
"//="                           return OP_INPLACE_FLD;
">>="                           return OP_INPLACE_LSH;
"<<="                           return OP_INPLACE_RSH;
"&="                            return OP_INPLACE_AND;
"^="                            return OP_INPLACE_XOR;
"|="                            return OP_INPLACE_OR;
"//"                            return OP_FLD;
"<<"                            return OP_LSH;
">>"                            return OP_RSH;
"**"                            return OP_POW;
"<="                            return OP_LE;
">="                            return OP_GE;
"=="                            return OP_EQ;
"!="                            return OP_NE;

"("                             in_enclosure++; return yytext[0];
"["                             in_enclosure++; return yytext[0];
"{"                             in_enclosure++; return yytext[0];
")"                             in_enclosure--; return yytext[0];
"]"                             in_enclosure--; return yytext[0];
"}"                             in_enclosure--; return yytext[0];

0[xX]{H}+[lL]?                  return lexer_process_integer (yytext, yyleng);
0{O}+[lL]?                      return lexer_process_integer (yytext, yyleng);
{D}+[lL]?                       return lexer_process_integer (yytext, yyleng);
{D}+[jJ]                        return lexer_process_integer (yytext, yyleng);

{D}+{E}[jJ]?                    return lexer_process_float (yytext, yyleng);
{D}*"."{D}+({E})?[jJ]?          return lexer_process_float (yytext, yyleng);
{D}+"."{D}*({E})?[jJ]?          return lexer_process_float (yytext, yyleng);

{L}({L}|{D})*                   return lexer_process_name (yytext);

{Q}                             lexer_quoted_begin (yytext);
<DQ,SQ,TDQ,TSQ>\\\n             /* escaped newline - do nothing */
<DQ,SQ,TDQ,TSQ>\\\\             lexer_quoted_append_chr ('\\');
<DQ,SQ,TDQ,TSQ>\\\"             lexer_quoted_append_chr ('"');
<RDQ,RSQ,RTDQ,RTSQ>\\\"         lexer_quoted_append_str (yytext);
<DQ,SQ,TDQ,TSQ>\\'              lexer_quoted_append_chr ('\'');
<RDQ,RSQ,RTDQ,RTSQ>\\'          lexer_quoted_append_str (yytext);
<TDQ,TSQ,RTDQ,RTSQ>(\"|')       lexer_quoted_append_str (yytext);
<DQ,SQ,TDQ,TSQ>\\a              lexer_quoted_append_chr ('\a');
<DQ,SQ,TDQ,TSQ>\\b              lexer_quoted_append_chr ('\b');
<DQ,SQ,TDQ,TSQ>\\f              lexer_quoted_append_chr ('\f');
<DQ,SQ,TDQ,TSQ>\\n              lexer_quoted_append_chr ('\n');
<DQ,SQ,TDQ,TSQ>\\r              lexer_quoted_append_chr ('\r');
<DQ,SQ,TDQ,TSQ>\\t              lexer_quoted_append_chr ('\t');
<DQ,SQ,TDQ,TSQ>\\v              lexer_quoted_append_chr ('\v');
<DQ,SQ,TDQ,TSQ>\\{O}{1,3}       lexer_quoted_append_oct (&yytext[1]);
<DQ,SQ,TDQ,TSQ>\\x{H}{1,2}      lexer_quoted_append_hex (&yytext[2]);
<DQ,SQ,TDQ,TSQ>\\.              lexer_quoted_append_chr (yytext[1]);
<DQ>[^\\\n\"]+                  lexer_quoted_append_str (yytext);
<RDQ>[^\"]+                     lexer_quoted_append_str (yytext);
<SQ>[^\\\n']+                   lexer_quoted_append_str (yytext);
<RSQ>[^']+                      lexer_quoted_append_str (yytext);
<TDQ,TSQ>[^\\\"']+              lexer_quoted_append_str (yytext);
<RTDQ,RTSQ>[^\"']+              lexer_quoted_append_str (yytext);
<DQ,RDQ>\"({WS}|\\\n)*{Q}       lexer_quoted_concat (&yytext[1]);
<SQ,RSQ>'({WS}|\\\n)*{Q}        lexer_quoted_concat (&yytext[1]);
<TDQ,RTDQ>\"\"\"({WS}|\\\n)*{Q} lexer_quoted_concat (&yytext[3]);
<TSQ,RTSQ>'''({WS}|\\\n)*{Q}    lexer_quoted_concat (&yytext[3]);
<DQ,RDQ>\"                      return lexer_quoted_end ();
<SQ,RSQ>'                       return lexer_quoted_end ();
<TDQ,RTDQ>\"\"\"                return lexer_quoted_end ();
<TSQ,RTSQ>'''                   return lexer_quoted_end ();
<DQ,SQ,RDQ,RSQ>\n               { yylloc.first_column--;
                                  return yyerror (E_EOLS); }
<DQ,SQ,RDQ,RSQ><<EOF>>          { yylloc.first_column--;
                                  return yyerror (E_EOLS); }
<TDQ,TSQ,RTDQ,RTSQ><<EOF>>      { yylloc.first_column--;
                                  return yyerror (E_EOLS); }

<BOL>\n                         { if (is_interactive && lexer_flush ())
                                  return eof_token; }
<BOL>{WS}*("#"[^\n]*)?\n        /* whitespace - do nothing */
<BOL>.*\n                       { gint token = lexer_indent (yytext);
                                  if (token >= 0) return token; }

{WS}+                           /* whitespace - do nothing */
\\\n                            /* escaped newline - do nothing */
("#"[^\n]*)?\n                  { if (!in_enclosure) {
                                  yy_push_state (BOL); return NEWLINE; } }

"?"                             return yyerror (E_TOKEN);
.                               return (gint) yytext[0];

<<EOF>>                         if (lexer_flush ()) return eof_token;

%%

const gint PCL_EVAL_INPUT = EIN;
const gint PCL_FILE_INPUT = FIN;
const gint PCL_SINGLE_INPUT = SIN;

static gint
lexer_start (gint token)
{
        /* GNU Bison only supports a single start rule, but we need more than
         * one to support different kinds of input (eval, file, or single).
         * To get around this limitation, we fake multiple start rules by
         * doing a little dance where the lexer is placed in the appropriate
         * "start" mode before calling yyparse().  In each of these start modes
         * we match any ol' character, put it back in the input stream to be
         * rescanned on the next pass, exit "start" mode, and return the
         * appropriate start token to the parser.  The parser uses the start
         * token to activate the appropriate top-level grammar rules. */

        yyless (0);
        yy_pop_state ();
        yy_push_state (BOL);
        if (token == SINGLE_INPUT)
                eof_token = NEWLINE;
        else
                eof_token = YY_NULL;
        return token;
}

static gint
lexer_input (gchar *buffer, gsize max_size)
{
        gint num_chars_read;

        if (is_interactive)
        {
#ifdef HAVE_LIBREADLINE
                /* You may be wondering what the hell is up with the setjmp()
                 * call.  GNU Readline doesn't handle signals the way we would
                 * like.  We would like for the user to hit ^C during keyboard
                 * input and have that generate a KeyboardInterrupt exception.
                 * Normally (see the non-readline version of this below) we
                 * would install a SIGINT handler that logs an interrupt in
                 * the signal module and causes the input-reading function
                 * (e.g. fgets) to fail and set errno to EINTR to indicate
                 * that an interrupt occurred.  But that won't work in this
                 * case.  Readline's manual states:
                 *
                 *    If and when the calling application's signal handler
                 *    returns, Readline will reinitialize the terminal and
                 *    continue to accept input.
                 * 
                 * But we don't want to continue accepting input, so we need a
                 * way to prevent our signal handling function from returning
                 * back into the readline() call.  To do this we install a
                 * temporary SIGINT handler.  The SIGINT handler simply calls
                 * longjmp() to force the instruction pointer to a jump point
                 * that we establish here with the setjmp() call.  Upon
                 * jumping, setjmp() will return a non-zero value, dropping us
                 * into the "if" block where we can then perform our *real*
                 * signal handling logic.
                 *
                 * XXX Also, it would seem that Readline also blocks SIGINT.
                 *     So we need to unblock than when handling a SIGINT.
                 */

                static gboolean rl_init = FALSE;
                struct sigaction sa_temp, sa_save;
                gchar *line;

                /* readline initialization */
                if (G_UNLIKELY (!rl_init))
                {
                        rl_instream = yyin;
                        rl_outstream = yyout;

                        /* disable TAB completion */
                        rl_bind_key ('\t', rl_insert);

                        rl_init = TRUE;
                }

                sa_temp.sa_handler = lexer_signal_handler;
                sigemptyset (&sa_temp.sa_mask);
                sa_temp.sa_flags = 0;

                /* XXX not checking return value */
                sigaction (SIGINT, &sa_temp, &sa_save);

                if (setjmp (env))
                {
                        sigset_t signal_mask;

                        /* unblock SIGINT */
                        sigemptyset (&signal_mask);
                        sigaddset (&signal_mask, SIGINT);
                        sigprocmask (SIG_UNBLOCK, &signal_mask, NULL);

                        /* XXX not checking return value */
                        sigaction (SIGINT, &sa_save, NULL);

                        pcl_error_set_interrupt ();
                        pcl_error_check_signals ();
                        goto except;
                }

                line = readline (cur_prompt);

                /* XXX not checking return value */
                sigaction (SIGINT, &sa_save, NULL);

                if (line == NULL)
                {
                        error_code = PCL_ERROR_EOF;
                        goto except;
                }
                if (*line != '\0')
                        add_history (line);

                /* XXX double-buffering the input */
                g_strlcpy (buffer, line, max_size - 1);
                g_strlcat (buffer, "\n", max_size);
                free (line);  /* not g_free() */

#else           /* --- the non-readline version --- */

                errno = 0;
                fputs (cur_prompt, yyout);
                if (fgets (buffer, (gint) max_size, yyin) == NULL)
                {
                        if (feof (yyin))
                        {
                                error_code = PCL_ERROR_EOF;
                                goto except;
                        }
                        if (errno == EINTR)
                        {
                                /* XXX Skipping some thread stuff. */
                                if (!pcl_error_check_signals ())
                                        goto except;
                        }
                        if (pcl_os_interrupt_occurred ())
                                goto except;
                        g_error ("%s: fgets() failed", G_STRFUNC);
                }

#endif /* HAVE_LIBREADLINE */
                num_chars_read = strlen (buffer);
                if (num_chars_read > 1)
                        cur_prompt = alt_prompt;
        }
        else
        {
                errno = 0;
                num_chars_read = fread (buffer, 1, max_size, yyin);
                while (ferror (yyin))
                {
                        if (errno != EINTR)
                                g_error ("%s: fread() failed", G_STRFUNC);
                        errno = 0;
                        clearerr (yyin);
                        num_chars_read = fread (buffer, 1, max_size, yyin);
                }
        }

        return num_chars_read;

except:

        fputc ('\n', yyout);
        return 0;
}

static gint
lexer_flush (void)
{
        /* If the last line of the input buffer is indented, we find ourselves
         * in a situation where the lexer has no more source code to read, but
         * the parser is still expecting DEDENT tokens.  So we have to somehow
         * "flush" the lexer of all pending DEDENT tokens.
         *
         * To do with this we set the lexer to 'FLUSH' mode and switch to a
         * new input buffer consisting of a single character for each pending
         * DEDENT token to be returned to the parser.  For example, if the
         * parser is expecting three DEDENT tokens, we switch to an input
         * buffer consisting of the string 'DDD'.  The number of DEDENT tokens
         * to be returned is determined from the indentation level.  When the
         * new input buffer is exhausted, we come back to this function to
         * free up resources and put the lexer back in it's initial mode. */

        static YY_BUFFER_STATE buffer = NULL;
        static gchar base[MAXINDENT + 8];  /* leave room for EOB chars */

        if (buffer != NULL)
        {
                /* second pass */
                g_assert (YY_START == FLUSH);
                yy_delete_buffer (buffer);
                yy_pop_state ();
                buffer = NULL;
        }
        else if (indent_level > 0)
        {
                /* first pass */
                gchar *cp = base;
                while (indent_level-- > 0)
                        *cp++ = 'D';
                *cp++ = YY_END_OF_BUFFER_CHAR;
                *cp++ = YY_END_OF_BUFFER_CHAR;
                g_assert (cp - base < sizeof (base));
                buffer = yy_scan_buffer (base, cp - base);
                g_assert (buffer != NULL);
                yy_push_state (FLUSH);
        }

        return (buffer == NULL);
}

static gint
lexer_indent (const gchar *text)
{
        gint indent = 0;
        gint whitespace = 0;
        const gchar *cp = text;

        g_assert (pending_dedents == 0);

        /* ignore formfeed */
        if (*cp == '\f')
        {
                whitespace++;
                cp++;
        }

        /* calculate whitespace and indentation level */
        while (*cp == ' ' || *cp == '\t')
        {
                if (*cp++ == '\t')
                        indent += TABSIZE - indent % TABSIZE;
                else
                        indent++;
                whitespace++;
        }

        /* put back everything after the whitespace */
        yy_pop_state ();
        yylloc.last_line--;
        yylloc.last_column = whitespace;
        yyless (whitespace);

        /* indent */
        if (indent > indent_stack[indent_level])
        {
                if (indent_level >= MAXINDENT)
                {
                        yylloc.first_column = yylloc.last_column;
                        return yyerror (E_TOODEEP);
                }
                indent_stack[++indent_level] = indent;
                return INDENT;
        }

        /* dedent */
        if (indent < indent_stack[indent_level])
        {
                while (indent < indent_stack[indent_level])
                {
                        indent_level--;
                        pending_dedents++;
                }
                if (indent != indent_stack[indent_level])
                {
                        yylloc.first_column = yylloc.last_column;
                        return yyerror (E_DEDENT);
                }
                pending_dedents--;
                return DEDENT;
        }

        return -1;  /* success -- no token */
}

static gint
lexer_process_float (gchar *text, gint length)
{
        PclNodeType type;
        gchar last = text[length - 1];

        if (last == 'j' || last == 'J')
                type = PCL_NODE_TYPE_IMAGINARY;
        else
                type = PCL_NODE_TYPE_FLOAT;
        yylval.node = NEW_TREE_NODE (type, yylloc);
        PCL_NODE_STRING (yylval.node) = g_strdup (text);
        return NUMBER;
}

static gint
lexer_process_integer (gchar *text, gint length)
{
        PclNodeType type;
        gchar last = text[length - 1];

        if (last == 'j' || last == 'J')
                type = PCL_NODE_TYPE_IMAGINARY;
        else
                type = PCL_NODE_TYPE_INTEGER;
        yylval.node = NEW_TREE_NODE (type, yylloc);
        PCL_NODE_STRING (yylval.node) = g_strdup (text);
        return NUMBER;
}

static gint
lexer_process_string (gchar *text)
{
        yylval.node = NEW_TREE_NODE (PCL_NODE_TYPE_STRING, yylloc);
        PCL_NODE_STRING (yylval.node) = g_strdup (text);
        return STRING;
}

static gint
lexer_process_name (gchar *text)
{
        yylval.node = NEW_TREE_NODE (PCL_NODE_TYPE_NAME, yylloc);
        PCL_NODE_STRING (yylval.node) = g_intern_string (text);
        PCL_NODE_FLAGS (yylval.node) = PCL_NODE_FLAG_INTERNED;
        return NAME;
}

static void
lexer_update_yylloc (void)
{
        gchar *cp = yytext;
        gchar *bol = NULL;

        yylloc.first_line = yylloc.last_line;
        yylloc.first_column = yylloc.last_column;

        while (*cp != 0)
                if (*cp++ == '\n')
                {
                        bol = cp;
                        yylloc.last_line++;
                }
        if (bol != NULL)
                yylloc.last_column = cp - bol;
        else
                yylloc.last_column += yyleng;
}

static void
lexer_quoted_begin (const gchar *text)
{
        lexer_quoted_push_state (text);
        if (string_buffer == NULL)
                string_buffer = g_string_sized_new (0x4000);  /* 16K */
        else
                g_string_set_size (string_buffer, 0);
}

static void
lexer_quoted_concat (const gchar *text)
{
        yy_pop_state ();
        lexer_quoted_push_state (text);
}

static void
lexer_quoted_append_chr (gchar c)
{
        g_string_append_c (string_buffer, c);
}

static void
lexer_quoted_append_hex (const gchar *hex)
{
        guint p = 0;
        sscanf (hex, "%x", &p);
        lexer_quoted_append_chr ((gchar) p & 0xFF);
}

static void
lexer_quoted_append_oct (const gchar *oct)
{
        guint p = 0;
        sscanf (oct, "%o", &p);
        lexer_quoted_append_chr ((gchar) p & 0xFF);
}

static void
lexer_quoted_append_str (const gchar *str)
{
        g_string_append (string_buffer, str);
}

static void
lexer_quoted_push_state (const gchar *text)
{
        gint raw = 0;
        gint quotes = 0;
        const gchar *cp = text;

        while (*cp != '\0')
        {
                switch (*cp++)
                {
                        case 'r':
                        case 'R':
                                raw++;
                                break;
                        case '\'':
                                quotes++;
                                break;
                        case '"':
                                quotes--;
                                break;

                        /* skip whitespace */
                }
        }

        g_assert (ABS (quotes) == 1 || ABS (quotes) == 3);

        switch (quotes)
        {
                case -1:  /*  "  */
                        yy_push_state (raw ? RDQ : DQ);
                        break;
                case +1:  /*  '  */
                        yy_push_state (raw ? RSQ : SQ);
                        break;
                case -3:  /* """ */
                        yy_push_state (raw ? RTDQ : TDQ);
                        break;
                case +3:  /* ''' */
                        yy_push_state (raw ? RTSQ : TSQ);
                        break;
        }
}

static gint
lexer_quoted_end (void)
{
        yy_pop_state ();
        return lexer_process_string (string_buffer->str);
}

gint
yyerror (const gchar *message)
{
        g_debug ("(%s) %s", G_STRFUNC, message);

        if (pcl_error_occurred ())
        {
                /* Don't overwrite existing errors. */
                g_debug ("(%s) Skipping due to existing error", G_STRFUNC);
        }
        else
        {
                PclObject *tuple;

                switch (yychar)
                {
                        case INDENT:
                                yylloc.first_column = yylloc.last_column;
                                message = "unexpected indent";
                                break;
                        case DEDENT:
                                yylloc.first_column = yylloc.last_column;
                                message = "unexpected unindent";
                                break;
                        default:
                                message = "invalid syntax";
                                break;
                }

                tuple = pcl_build_value ("(siis)",
                        input_name,
                        yylloc.first_line,
                        yylloc.first_column,
                        message);
                pcl_error_set_object (pcl_exception_syntax_error (), tuple);
                pcl_object_unref (tuple);
        }

        return YY_NULL;
}

static PclParseInfo *
parse_input_common (gint start)
{
        PclParseInfo *parse_info = pcl_parse_info_new (input_name);

        error_code = 0;
        in_enclosure = 0;
        indent_level = 0;
        pending_dedents = 0;
        indent_stack[0] = 0;

        yylloc.first_line = yylloc.last_line = 1;
        yylloc.first_column = yylloc.last_column = 0;

        yy_push_state (start);
        if (yyparse () == 0)
        {
                /* embed input name in root node */
                GNode *parse_tree = yylval.node;
                parse_info->parse_tree = parse_tree;
                parse_info->error_code = error_code;
                PCL_NODE_STRING (parse_tree) = g_strdup (input_name);
        }

        if (YY_START == FLUSH)
                lexer_flush ();

        /* reset lexer */
        while (YY_START != INITIAL)
                yy_pop_state ();

        if (pcl_error_occurred ())
        {
                pcl_parse_info_destroy (parse_info);
                return NULL;
        }

        return pcl_parse_info_normalize (parse_info);
}

PclParseInfo *
pcl_parse_input_file (FILE *stream, const gchar *filename, gint start)
{
        PclParseInfo *parse_info;
        YY_BUFFER_STATE buffer;

        is_interactive = isatty (fileno (stream));
        input_name = (filename != NULL) ? filename : "?";
        buffer = yy_create_buffer (stream, YY_BUF_SIZE);
        yy_switch_to_buffer (buffer);
        parse_info = parse_input_common (start);
        yy_delete_buffer (buffer);
        input_name = NULL;
        return parse_info;
}

PclParseInfo *
pcl_parse_input_file_with_prompts (FILE *stream, const gchar *filename,
                                   gint start, const gchar *ps1,
                                   const gchar *ps2)
{
        PclParseInfo *parse_info;
        cur_prompt = ps1, alt_prompt = ps2;
        parse_info = pcl_parse_input_file (stream, filename, start);
        cur_prompt = alt_prompt = NULL;
        return parse_info;
}

PclParseInfo *
pcl_parse_input_string (const gchar *string, gint start)
{
        PclParseInfo *parse_info;
        YY_BUFFER_STATE buffer;
        GString *bytes;

        is_interactive = FALSE;
        input_name = "<string>";
        bytes = g_string_new (string);
        g_string_append_c (bytes, '\n');
        g_string_append_c (bytes, YY_END_OF_BUFFER_CHAR);
        g_string_append_c (bytes, YY_END_OF_BUFFER_CHAR);
        buffer = yy_scan_buffer (bytes->str, bytes->len);
        parse_info = parse_input_common (start);
        yy_delete_buffer (buffer);
        g_string_free (bytes, TRUE);
        input_name = NULL;
        return parse_info;
}
