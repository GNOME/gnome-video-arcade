import gc, sys

def graph(*objects):
        '''Print a reference graph of the given objects, showing any cycles.

        If no objects are given, print a reference graph for all objects
        currently being tracked by the garbage collector.'''

        def describe(x):
                if hasattr(x, '__name__'):
                        return repr(x.__name__)
                if isinstance(x, (int, float, str)):
                        if len(repr(x)) < 30:  # Not too long
                                return repr(x)
                return ''

        def indent(n):
                return '   ' * n

        def process(this, level, visited):
                id = sys.id(this)
                referents = gc.get_referents(this)
                ref_cycle = referents and id in visited
                format = indent(level) + '<%s object at %s>'
                print format % (type(this).__name__, hex(id)),
                print describe(this)
                if ref_cycle:
                        print indent(level + 1) + '(REFERENCE CYCLE)'
                elif level > 0 and referents and id not in master_dict:
                        print indent(level + 1) + '(SEE ABOVE)'
                else:
                        visited.append(id)
                        if id in master_dict:
                                del master_dict[id]
                        while referents:
                                # Here we iterate in order to make it easier
                                # to correlate referents with C-level object
                                # pointers in built-in types.
                                next = referents.pop(0)
                                process(next, level + 1, visited)

        master_list = list(objects or gc.get_objects())
        master_dict = dict([(sys.id(x), x) for x in master_list])

        while master_list:
                # gc.get_objects() tends to return objects in the order they
                # were created.  By iterating in reverse order, we should get
                # fewer top-level listings (which is what we want).
                next = master_list.pop()
                if sys.id(next) in master_dict:
                        process(next, 0, [])

if __name__ == '__main__':
        graph()
